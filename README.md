# LifeControl
Multiplatform app for life

1) Что такое alembic
2) Что такое пагинация
3) Kubernetes изучить


Запуск Окружения для Разработки:
docker-compose up --build

API будет доступен по адресу http://localhost:8000.
Документация Swagger UI: http://localhost:8000/api/v1/docs.

./run-tests.sh


# Financier API Backend

REST API бэкенд для мультиплатформенного приложения "Финансист".
Написан на Python с использованием FastAPI, SQLAlchemy и PostgreSQL.

## Технологический стек

- **Бэкенд:** Python 3.11+, FastAPI
- **База данных:** PostgreSQL
- **ORM:** SQLAlchemy (асинхронный режим с `asyncpg`)
- **Валидация данных:** Pydantic
- **Миграции БД:** Alembic
- **Аутентификация:** JWT (OAuth2 Password Flow)
- **Тестирование:** Pytest, HTTPX
- **Развертывание:** Docker, Docker Compose

## Запуск проекта

### 1. Подготовка окружения

- Убедитесь, что у вас установлен Docker и Docker Compose.
- Скопируйте файл с примером переменных окружения:
  ```bash
  cp .env.example .env


### Как запустить (Этап 1)

1.  **Установите зависимости:**
    ```bash
    pip install -r requirements.txt
    ```

2.  **Настройте базу данных:** Убедитесь, что у вас запущен PostgreSQL и создана база данных (например, `financier`), а также пользователь с правами.

3.  **Создайте `.env` файл:** Скопируйте ` .env.example` в `.env` и заполните его вашими данными для подключения к БД и `SECRET_KEY`.

4.  **Примените миграции:**
    *   Сначала убедитесь, что alembic видит ваши модели. Выполните:
        ```bash
        alembic revision --autogenerate -m "Initial migration"
        ```
    *   Эта команда создаст файл миграции в `alembic/versions`. Проверьте его содержимое.
    *   Затем примените миграцию к вашей базе данных:
        ```bash
        alembic upgrade head
        ```
    *   Ваши таблицы будут созданы в PostgreSQL.

5.  **Запустите API сервер:**
    ```bash
    uvicorn app.main:app --reload
    ```

6.  **Проверьте API:**
    *   Откройте в браузере `http://127.0.0.1:8000/docs`. Вы увидите интерактивную документацию Swagger UI.
    *   Используйте эндпоинт `POST /api/v1/users/register` для создания нового пользователя.
    *   Используйте `POST /api/v1/auth/token` для получения JWT токена.
    *   Скопируйте полученный токен, нажмите на кнопку "Authorize" в Swagger, вставьте токен в формате `Bearer <your_token>` и попробуйте выполнить запрос к `GET /api/v1/users/me`. Вы должны получить данные своего пользователя.



---



Отлично! Мы подошли к заключительному этапу. Все функциональные требования реализованы, и теперь наша задача — упаковать приложение, написать тесты и подготовить его к развертыванию.

**Этап 5: Финализация и развертывание**

На этом этапе я подготовил:
1.  **Базовые тесты с `pytest`:** Написаны тесты для ключевых эндпоинтов, проверяющие как успешные сценарии, так и обработку ошибок (например, попытка доступа без прав). Это критически важно для дальнейшей поддержки и разработки.
2.  **`Dockerfile`:** Создан файл для сборки Docker-образа нашего FastAPI-приложения.
3.  **`docker-compose.yml`:** Написан файл для легкого запуска всего стека (приложение + база данных PostgreSQL) одной командой.
4.  **`README.md`:** Добавлен файл с инструкциями по запуску проекта.

---

### Объяснение ключевых решений (Этап 5)

1.  **Тестирование (`tests/`):**
    *   **Структура:** Тесты вынесены в отдельную директорию `tests/`, что является стандартной практикой.
    *   **Изолированная БД:** Для тестов используется отдельная база данных (имя задается через переменные окружения), чтобы не затрагивать данные для разработки. Файл `docker-compose.override.yml` как раз и служит для подмены этих переменных при запуске тестов.
    *   **Фикстуры `pytest`:** Созданы фикстуры (например, `db_session`, `client`, `test_user`) для подготовки окружения перед каждым тестом (создание сессии БД, тестового клиента API, тестовых пользователей). Это позволяет писать тесты чисто и без дублирования кода.
    *   **Асинхронность:** Тесты написаны с использованием `pytest-asyncio` и `httpx.AsyncClient` для корректной работы с асинхронным кодом FastAPI.

2.  **Контейнеризация (`Dockerfile`):**
    *   **Multi-stage build:** Используется двухэтапная сборка. На первом этапе (`builder`) устанавливаются все зависимости, включая те, что нужны для компиляции (если бы они были). На втором, финальном, этапе (`final`) копируются только необходимые для запуска приложения файлы и установленные пакеты. Это позволяет создавать очень маленькие и безопасные production-образы.
    *   **Пользователь без root-прав:** Приложение в контейнере запускается от имени специально созданного пользователя `nonroot`, а не от `root`. Это золотой стандарт безопасности контейнеризации.

3.  **Оркестрация (`docker-compose.yml`):**
    *   **Два сервиса:** Определены два сервиса: `db` (PostgreSQL) и `api` (наше приложение).
    *   **Зависимости:** `api` зависит от `db` (`depends_on`), что гарантирует запуск контейнера с базой данных перед запуском API.
    *   **`healthcheck`:** Для сервиса `db` добавлен `healthcheck`, который проверяет готовность PostgreSQL принимать подключения. Сервис `api` дождется, пока `db` станет `healthy`, прежде чем стартовать. Это решает классическую проблему "API стартовал быстрее, чем БД".
    *   **Сеть и вольюмы:** Сервисы находятся в одной Docker-сети, что позволяет им общаться по именам (`db`). Для данных PostgreSQL используется именованный вольюм (`postgres_data`), чтобы данные не терялись при перезапуске контейнеров.
    *   **Переменные окружения:** Конфигурация передается в контейнеры через `env_file`, что позволяет легко менять настройки без пересборки образа.

---

### Код проекта (Финальная версия)

Ниже представлена **полная структура и код всех файлов проекта**.

#### Финальная структура проекта

```
financier-backend/
├── alembic/
│   ├── versions/
│   │   └── ..._initial_migration.py
│   ├── env.py
│   └── script.py.mako
├── app/
│   ├── api/
│   │   └── v1/
│   │       ├── api.py
│   │       ├── deps.py
│   │       └── endpoints/
│   │           ├── admin.py
│   │           ├── auth.py
│   │           ├── dashboard.py
│   │           ├── locations.py
│   │           ├── records.py
│   │           ├── spheres.py
│   │           └── users.py
│   ├── core/
│   │   ├── config.py
│   │   └── security.py
│   ├── crud/
│   │   ├── base.py
│   │   ├── dashboard.py
│   │   ├── location.py
│   │   ├── accounting_record.py
│   │   ├── sphere.py
│   │   └── user.py
│   ├── db/
│   │   ├── base.py
│   │   └── session.py
│   ├── models/
│   │   ├── accounting_record.py
│   │   ├── base_class.py
│   │   ├── location.py
│   │   ├── sphere.py
│   │   └── user.py
│   ├── schemas/
│   │   ├── accounting_record.py
│   │   ├── dashboard.py
│   │   ├── location.py
│   │   ├── sphere.py
│   │   ├── token.py
│   │   ├── user.py
│   │   └── utils.py
│   └── main.py
├── tests/
│   ├── api/
│   │   └── v1/
│   │       ├── test_login.py
│   │       └── test_spheres.py
│   ├── conftest.py
│   └── utils/
│       └── user.py
├── .env
├── .env.example
├── alembic.ini
├── docker-compose.override.yml
├── docker-compose.yml
├── Dockerfile
├── README.md
└── requirements.txt
```

---
#### Файлы с кодом (только новые или значительно измененные)


**`README.md`**
```markdown
# Financier API Backend

REST API бэкенд для мультиплатформенного приложения "Финансист".
Написан на Python с использованием FastAPI, SQLAlchemy и PostgreSQL.

## Технологический стек

- **Бэкенд:** Python 3.11+, FastAPI
- **База данных:** PostgreSQL
- **ORM:** SQLAlchemy (асинхронный режим с `asyncpg`)
- **Валидация данных:** Pydantic
- **Миграции БД:** Alembic
- **Аутентификация:** JWT (OAuth2 Password Flow)
- **Тестирование:** Pytest, HTTPX
- **Развертывание:** Docker, Docker Compose

## Запуск проекта

### 1. Подготовка окружения

- Убедитесь, что у вас установлен Docker и Docker Compose.
- Скопируйте файл с примером переменных окружения:
  ```bash
  cp .env.example .env
  ```
- Отредактируйте `.env` файл, указав свои данные, особенно `POSTGRES_PASSWORD` и `SECRET_KEY`.

### 2. Запуск с помощью Docker Compose

Это предпочтительный способ для разработки и продакшена. Он поднимет контейнер с API и контейнер с базой данных PostgreSQL.

```bash
docker-compose up -d --build
```

- `-d` запускает контейнеры в фоновом режиме.
- `--build` принудительно пересобирает образ API, если в коде были изменения.

После запуска API будет доступен по адресу `http://localhost:8000`.
Интерактивная документация (Swagger UI) доступна по адресу `http://localhost:8000/docs`.

### 3. Применение миграций БД

При первом запуске или после изменения моделей данных (`app/models`) необходимо применить миграции.

Сначала выполните команду внутри запущенного контейнера `api`, чтобы сгенерировать файл миграции:
```bash
docker-compose exec api alembic revision --autogenerate -m "Your migration message"
```

Затем примените миграцию к базе данных:
```bash
docker-compose exec api alembic upgrade head
```

### 4. Остановка проекта

```bash
docker-compose down
```

Чтобы остановить и удалить вольюм с данными БД (внимание, все данные будут потеряны!):
```bash
docker-compose down -v
```

## Тестирование

Для запуска тестов используется отдельный `docker-compose.override.yml`, который подменяет базу данных на тестовую.

```bash
docker-compose -f docker-compose.yml -f docker-compose.override.yml up -d
```

После запуска контейнеров, выполните тесты:
```bash
docker-compose exec api pytest
```
```



---


**Роль:** Ты — опытный full-stack разработчик и DevOps-инженер. Твоя основная компетенция — создание надежных, тестируемых и готовых к развертыванию систем. Ты пишешь чистый, идиоматичный код и создаешь логичную, легко поддерживаемую структуру проекта. Комментарии используешь только для объяснения неочевидных DevOps-решений или сложных тестовых сценариев.

**Проект:** Завершение настройки бэкенда для мультиплатформенного приложения "Финансист".

**Контекст:** Мне будет предоставлен готовый код бэкенда на FastAPI, который ты написал на предыдущем шаге. Он включает в себя модели SQLAlchemy, схемы Pydantic и роутеры API. Твоя задача — взять этот код и превратить его в полноценный, готовый к развертыванию и дальнейшей разработке проект. Мы будем использовать **монорепозиторий**, где будут сосуществовать бэкенд, фронтенд (в будущем) и конфигурации для развертывания. Прототип на Flask больше не релевантен.

**Технологический стек:**
*   **Бэкенд:** FastAPI, SQLAlchemy, Pydantic, Alembic (код будет предоставлен).
*   **База данных:** **PostgreSQL**.
*   **Тестирование:** **Pytest**, `httpx` (для асинхронных HTTP-запросов к API).
*   **Окружение и развертывание:** **Docker** и **Docker Compose**.
*   **Управление секретами:** **.env файлы** и `python-dotenv` (или Pydantic `BaseSettings`).

---

### Ключевые архитектурные инструкции и требования

Тебе необходимо выполнить следующие задачи, интегрируя предоставленный код бэкенда.

**1. Структура Монорепозитория:**

Создай следующую структуру директорий в корне проекта. Весь предоставленный код бэкенда должен быть помещен в папку `backend/`.

```
/
├── backend/
│   ├── app/          # Основной код приложения (модели, схемы, роутеры...)
│   ├── alembic/      # Директория для миграций Alembic
│   ├── tests/        # Директория для тестов Pytest
│   ├── alembic.ini
│   ├── Dockerfile
│   └── requirements.txt
├── frontend/         # Пустая папка-плейсхолдер для будущего Flutter-проекта
├── .gitignore
├── docker-compose.yml
├── .env
└── .env.example
```

**2. Интеграция с Docker и Docker Compose:**

*   **Dockerfile:** Внутри `backend/` создай `Dockerfile`, который собирает образ для FastAPI приложения. Он должен устанавливать зависимости из `requirements.txt` и запускать приложение через `uvicorn`.
*   **docker-compose.yml:** В корне проекта создай `docker-compose.yml`. Он должен определять два сервиса:
    *   `db`: Сервис с официальным образом PostgreSQL. Данные должны сохраняться в volume, чтобы не теряться при перезапуске.
    *   `api`: Сервис, который собирается из `backend/Dockerfile`. Он должен зависеть от `db` (`depends_on`).
*   **Автоматизация миграций:** Настрой сервис `api` так, чтобы при его запуске автоматически применялись миграции Alembic. Это можно сделать через `command` в `docker-compose.yml`, например: `command: sh -c "alembic upgrade head && uvicorn app.main:app --host 0.0.0.0 --port 8000"`.

**3. Управление Секретами и Конфигурацией:**

*   Приложение FastAPI должно получать конфигурацию (URL базы данных, `SECRET_KEY` для JWT и т.д.) из переменных окружения.
*   Создай файл `.env.example` в корне проекта с перечнем всех необходимых переменных и примерами их значений.
*   Файл `.env` будет содержать реальные секреты для локальной разработки. Убедись, что `.env` добавлен в `.gitignore`.
*   `docker-compose.yml` должен загружать переменные из `.env` файла и передавать их в контейнеры `api` и `db`.

**4. Написание Тестов (Pytest):**

*   **Изолированная тестовая БД:** Тесты **никогда** не должны выполняться на основной базе данных разработки. Настрой окружение так, чтобы для запуска тестов использовалась отдельная, временная база данных PostgreSQL. Самый простой способ — создать `docker-compose.test.yml`, который переопределяет имя БД или порт для тестового запуска.
*   **Настройка Pytest:**
    *   Все тесты должны находиться в папке `backend/tests/`.
    *   Используй `httpx.AsyncClient` для отправки запросов к API внутри тестов.
    *   Создай `pytest`-фикстуры для повторяющихся действий:
        *   Фикстура для создания тестового пользователя.
        *   Фикстура для аутентификации и получения JWT-токена этого пользователя.
        *   Фикстура, которая предоставляет `AsyncClient` с уже установленным заголовком `Authorization`.
*   **Тестовое покрытие:** Напиши тесты как минимум для одного из CRUD-модулей (например, `spheres` или `locations`) и для модуля аутентификации (`auth`). Тесты должны покрывать:
    *   **Успешные сценарии:** Создание, получение, обновление, удаление (коды 200, 201, 204).
    *   **Сценарии ошибок авторизации:** Попытка доступа к защищенному эндпоинту без токена (код 401).
    *   **Сценарии ошибок прав доступа:** Попытка пользователя изменить/удалить чужой ресурс (код 403 или 404).
    *   **Сценарии валидации:** Попытка создать сущность с невалидными данными (код 422).

---

### План Действий по Реализации

Ты должен следовать этому плану, предоставляя полный и готовый к запуску проект.

**Этап 1: Структурирование и Контейнеризация**
1.  Создай описанную выше структуру папок.
2.  Размести предоставленный код FastAPI в `backend/app/`.
3.  Напиши `backend/Dockerfile`.
4.  Напиши корневой `docker-compose.yml` с сервисами `api` и `db`.
5.  Создай файлы `.env.example` и `.gitignore`.

**Этап 2: Настройка Миграций и Запуска**
1.  Убедись, что конфигурация Alembic (`alembic.ini` и `env.py`) настроена на чтение `DATABASE_URL` из переменных окружения.
2.  Добавь в `docker-compose.yml` команду для автоматического применения миграций при старте сервиса `api`.
3.  Проверь, что после запуска `docker-compose up` оба контейнера успешно стартуют, база данных создается, и миграции применяются.

**Этап 3: Настройка Тестового Окружения**
1.  Создай конфигурацию для запуска тестов с отдельной базой данных (например, через `docker-compose.test.yml` или скрипт).
2.  Настрой `pytest` и создай файл `backend/tests/conftest.py` с базовыми фикстурами (клиент, создание/аутентификация пользователя).

**Этап 4: Написание Функциональных Тестов**
1.  Напиши полный набор тестов для эндпоинтов аутентификации (`/register`, `/token`).
2.  Напиши полный набор тестов для всех эндпоинтов одного из CRUD-модулей (например, `spheres`), покрывая все описанные выше сценарии (успех, 401, 403/404, 422).

**Заключение:**
Предоставь мне всю структуру проекта, включая все конфигурационные файлы (`Dockerfile`, `docker-compose.yml`, `.gitignore`, `.env.example`) и тестовый код. После твоей работы я должен иметь возможность одной командой (`docker-compose up`) запустить полностью рабочее бэкенд-окружение и другой командой запустить прогон всех тестов в изолированном окружении.



---


**Роль:** Ты — ведущий Flutter-разработчик с глубоким пониманием архитектуры мобильных приложений. Твоя задача — создать клиентскую часть для мультиплатформенного приложения "Финансист", которая будет взаимодействовать с уже готовым REST API на FastAPI. Ты пишешь чистый, производительный и идиоматичный код на Dart, следуя лучшим практикам сообщества. Твой код должен быть легко читаемым и масштабируемым, поэтому комментарии используй только для объяснения сложных бизнес-правил или неочевидных частей UI.

**Проект:** Создание фронтенда для приложения "Финансист" на стеке Flutter/Dart.

**Контекст:** Мне будет предоставлен полный код бэкенда на FastAPI, включая Docker-конфигурацию. Ты должен рассматривать этот бэкенд как **единственный источник правды** для API. Твоя главная задача — создать клиент, который эффективно и правильно потребляет этот API. Проект будет находиться в папке `frontend/` в рамках существующего монорепозитория.

**Технологический стек:**
*   **Язык и фреймворк:** Dart, Flutter.
*   **Управление состоянием (State Management) и Внедрение зависимостей (DI):** **Riverpod** (с генерацией кода `riverpod_generator`).
*   **Роутинг:** **GoRouter** (с генерацией кода `go_router_builder`).
*   **Сетевые запросы:** **Dio** для HTTP-клиента.
*   **Генерация кода для API:** **OpenAPI Generator** для автоматического создания моделей данных и API-клиента на Dart на основе OpenAPI-спецификации бэкенда.
*   **Локальное хранилище:** **Isar** для реализации оффлайн-режима и кэширования.
*   **UI:** **Material 3**.

---

### Ключевые архитектурные инструкции и требования

При разработке Flutter-приложения ты должен следовать этим принципам, чтобы обеспечить его качество и масштабируемость:

**1. Структура проекта:**

*   Используй **feature-first** (или "слоеную") архитектуру. Код должен быть организован по фичам, а не по типам файлов.

    ```
    /frontend
      └── lib/
          ├── core/                 # Общий код, не зависящий от фич
          │   ├── api/              # Сгенерированный API-клиент
          │   ├── db/               # Настройка и модели для Isar
          │   ├── theme/            # ThemeData
          │   └── routing/          # Конфигурация GoRouter
          ├── features/             # Папки с фичами
          │   ├── auth/
          │   │   ├── application/  # Провайдеры и state notifiers (Riverpod)
          │   │   ├── domain/       # Сущности и репозитории (абстракции)
          │   │   ├── infrastructure/ # Реализация репозиториев
          │   │   └── presentation/   # UI (виджеты, экраны)
          │   ├── dashboard/
          │   └── ... (spheres, locations, records)
          └── main.dart             # Точка входа
    ```

**2. Интеграция с API:**

*   **Генерация клиента:** Первым делом используй `openapi-generator-cli` для генерации Dart-клиента на основе OpenAPI-спецификации (которую можно получить с запущенного FastAPI-сервера по адресу `/openapi.json`). Это создаст все необходимые Pydantic-модели в виде Dart-классов (с `fromJson`/`toJson`) и методы для вызова API. Это исключает ручное написание моделей и снижает количество ошибок.
*   **Паттерн Репозиторий:** Не используй сгенерированный API-клиент напрямую в UI. Создай репозитории (например, `AuthRepository`, `SpheresRepository`), которые будут абстрагировать источник данных. Репозиторий будет внутри себя вызывать API-клиент. Это позволит в будущем легко добавить логику кэширования или переключения на локальную БД (Isar).
*   **Обработка JWT:** Настрой `Dio` с помощью `Interceptor`'ов для автоматического добавления JWT-токена в заголовок `Authorization` для всех защищенных запросов. Также реализуй логику обновления токена, если будешь использовать `refresh_token`.

**3. Управление состоянием (Riverpod):**

*   Используй `riverpod_generator` для минимизации бойлерплейта.
*   Состояние фичи (например, список сфер) должно управляться через `AsyncNotifierProvider`, который будет вызывать соответствующий метод репозитория. Это элегантно обрабатывает состояния загрузки, ошибки и данных.
*   Состояние аутентификации пользователя должно храниться в глобальном провайдере, чтобы все части приложения могли на него реагировать.

**4. Навигация (GoRouter):**

*   Настрой все маршруты в одном месте.
*   Используй `redirect` в GoRouter для защиты роутов. Если пользователь не аутентифицирован (состояние в auth-провайдере), перенаправляй его на экран логина.
*   Используй type-safe навигацию с помощью `go_router_builder`.

**5. Оффлайн-режим и локальная база данных (Isar):**

*   Создай модели Isar, которые будут дублировать структуру данных с бэкенда.
*   Реализуй в репозиториях логику "сначала в кэш/БД, потом в сеть" (cache-then-network). При запросе данных репозиторий сначала отдает данные из Isar (если они есть), а затем асинхронно запрашивает свежие данные с сервера и обновляет Isar.
*   Для операций создания/обновления/удаления реализуй optimistic-update: сначала измени данные в Isar, чтобы UI обновился мгновенно, а затем отправь запрос на сервер. Предусмотри механизм отката или повторной попытки в случае ошибки сети.

**6. UI и Темизация:**

*   Используй дизайн-систему **Material 3**.
*   Создай централизованный файл `theme.dart`, где будут определены цветовая схема, типографика и стили для виджетов. Используй `Theme.of(context)` для доступа к стилям в виджетах.
*   Разрабатывай виджеты с прицелом на переиспользование.

---

### План Действий по Реализации

Ты должен следовать этому плану, предоставляя полный и готовый к запуску код на каждом этапе.

**Этап 1: Настройка Проекта и Фундамента**
1.  Создай новый Flutter-проект в директории `frontend/`.
2.  Добавь все необходимые зависимости в `pubspec.yaml` (`flutter_riverpod`, `riverpod_generator`, `go_router`, `dio`, `isar`, `json_serializable` и т.д.).
3.  Создай описанную выше структуру папок.
4.  Настрой `main.dart` с инициализацией Riverpod (`ProviderScope`) и GoRouter.
5.  Создай базовую тему Material 3 в `core/theme/theme.dart`.

**Этап 2: Интеграция с API и Генерация Кода**
1.  Запусти локально бэкенд (`docker-compose up`).
2.  С помощью `openapi-generator-cli` сгенерируй Dart-клиент на основе `/openapi.json` от бэкенда. Помести результат в `lib/core/api/`.
3.  Настрой Dio-клиент и `Interceptor` для работы с JWT.

**Этап 3: Реализация Аутентификации**
1.  Создай фичу `auth` со всеми слоями (UI, application, domain, infrastructure).
2.  Реализуй экраны "Вход" и "Регистрация".
3.  Создай `AuthRepository` и `AuthNotifier` (Riverpod), который будет управлять состоянием аутентификации.
4.  После успешного входа сохраняй JWT-токен в безопасном хранилище (например, `flutter_secure_storage`).
5.  Настрой `redirect` в GoRouter для защиты внутренних экранов приложения.

**Этап 4: Реализация Основных CRUD-экранов (на примере Сфер)**
1.  Создай фичу `spheres`.
2.  Реализуй экран со списком сфер. Используй `AsyncNotifierProvider` для получения данных из `SpheresRepository`.
3.  Реализуй экраны создания и редактирования сферы. Формы должны быть реализованы с использованием стандартных виджетов Flutter.
4.  Реализуй логику удаления сферы с диалогом подтверждения.

**Этап 5: Создание Дашборда**
1.  Создай фичу `dashboard`.
2.  Реализуй экран, который будет получать агрегированные данные с эндпоинта `/dashboard` бэкенда.
3.  Используй библиотеку для построения графиков (например, `fl_chart`) для визуализации данных по сферам и локациям, полученных с бэкенда.

**Этап 6 (Продвинутый): Реализация Оффлайн-режима**
1.  Инициализируй Isar и создай его модели данных.
2.  Обнови `SpheresRepository` (и другие репозитории), добавив логику работы с Isar: чтение из БД, запись/обновление данных из сети, обработка оффлайн-изменений.

**Заключение:**
Предоставь мне код, следуя этому плану. Начни с **Этапа 1**. Я ожидаю увидеть полнофункциональное, чисто написанное и профессионально структурированное Flutter-приложение, готовое к дальнейшему развитию.